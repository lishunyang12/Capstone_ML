/**
 * C Simulation Testbench for Siamese LSTM HLS
 *
 * Reads test vectors generated by generate_test_vectors.py,
 * runs the HLS top function, and compares against PyTorch reference.
 *
 * Compile (standalone):
 *   g++ -std=c++11 -O2 -o csim siamese_lstm.cpp siamese_lstm_tb.cpp -lm
 *   ./csim
 */

#include "siamese_lstm.h"
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <cstring>

#define TOLERANCE 1e-4f

// Path to test vectors (relative to where the binary runs)
// Vitis HLS csim runs from: <project>/solution1/csim/build/
// So we go 4 levels up to reach the prototype directory
#ifdef TEST_VECTORS_DIR
static const char *TEST_DIR = TEST_VECTORS_DIR;
#else
static const char *TEST_DIR = "../../../../hls/test_vectors";
#endif

// ---------------------------------------------------------------------------
// File I/O helpers
// ---------------------------------------------------------------------------

/**
 * Read a sequence file: first line is seq_len, then seq_len*INPUT_DIM floats.
 * Returns seq_len. Caller provides buffer of at least MAX_SEQ_LEN*INPUT_DIM.
 */
static int read_sequence(const char *path, float *buf) {
    FILE *f = fopen(path, "r");
    if (!f) {
        fprintf(stderr, "ERROR: cannot open %s\n", path);
        return -1;
    }

    int seq_len;
    if (fscanf(f, "%d", &seq_len) != 1) {
        fprintf(stderr, "ERROR: cannot read seq_len from %s\n", path);
        fclose(f);
        return -1;
    }

    int total = seq_len * INPUT_DIM;
    for (int i = 0; i < total; i++) {
        if (fscanf(f, "%f", &buf[i]) != 1) {
            fprintf(stderr, "ERROR: unexpected EOF at element %d in %s\n", i, path);
            fclose(f);
            return -1;
        }
    }

    fclose(f);
    return seq_len;
}

static float read_scalar(const char *path) {
    FILE *f = fopen(path, "r");
    if (!f) {
        fprintf(stderr, "ERROR: cannot open %s\n", path);
        return -999.0f;
    }
    float val;
    if (fscanf(f, "%f", &val) != 1) {
        fprintf(stderr, "ERROR: cannot read float from %s\n", path);
        fclose(f);
        return -999.0f;
    }
    fclose(f);
    return val;
}

static int read_embedding(const char *path, float *emb, int dim) {
    FILE *f = fopen(path, "r");
    if (!f) {
        fprintf(stderr, "ERROR: cannot open %s\n", path);
        return -1;
    }
    for (int i = 0; i < dim; i++) {
        if (fscanf(f, "%f", &emb[i]) != 1) {
            fprintf(stderr, "ERROR: unexpected EOF at element %d in %s\n", i, path);
            fclose(f);
            return -1;
        }
    }
    fclose(f);
    return 0;
}

// ---------------------------------------------------------------------------
// Run one test case
// ---------------------------------------------------------------------------
static int run_test(const char *name) {
    char path[512];

    // Allocate buffers
    static float seq1_buf[MAX_SEQ_LEN * INPUT_DIM];
    static float seq2_buf[MAX_SEQ_LEN * INPUT_DIM];

    // Read inputs
    snprintf(path, sizeof(path), "%s/%s_seq1.txt", TEST_DIR, name);
    int seq1_len = read_sequence(path, seq1_buf);
    if (seq1_len < 0) return 1;

    snprintf(path, sizeof(path), "%s/%s_seq2.txt", TEST_DIR, name);
    int seq2_len = read_sequence(path, seq2_buf);
    if (seq2_len < 0) return 1;

    // Read expected output
    snprintf(path, sizeof(path), "%s/%s_expected.txt", TEST_DIR, name);
    float expected = read_scalar(path);
    if (expected < -900.0f) return 1;

    // Read expected embeddings (for debug)
    float expected_emb1[EMBEDDING_DIM], expected_emb2[EMBEDDING_DIM];
    snprintf(path, sizeof(path), "%s/%s_emb1.txt", TEST_DIR, name);
    read_embedding(path, expected_emb1, EMBEDDING_DIM);
    snprintf(path, sizeof(path), "%s/%s_emb2.txt", TEST_DIR, name);
    read_embedding(path, expected_emb2, EMBEDDING_DIM);

    // Run HLS function
    float result = 0.0f;
    siamese_lstm_top(seq1_buf, seq2_buf, &result, seq1_len, seq2_len);

    // Compare
    float error = fabsf(result - expected);
    int pass = (error < TOLERANCE);

    printf("  %-15s | len1=%3d len2=%3d | expected=%.6f got=%.6f | err=%.2e | %s\n",
           name, seq1_len, seq2_len, expected, result, error,
           pass ? "PASS" : "FAIL");

    if (!pass) {
        // Debug: print expected embeddings
        printf("    Expected emb1: ");
        for (int i = 0; i < EMBEDDING_DIM; i++) printf("%.4f ", expected_emb1[i]);
        printf("\n    Expected emb2: ");
        for (int i = 0; i < EMBEDDING_DIM; i++) printf("%.4f ", expected_emb2[i]);
        printf("\n");
    }

    return pass ? 0 : 1;
}

// ---------------------------------------------------------------------------
// Main
// ---------------------------------------------------------------------------
int main() {
    printf("============================================================\n");
    printf("Siamese LSTM HLS â€” C Simulation Testbench\n");
    printf("============================================================\n");
    printf("Tolerance: %.0e\n\n", TOLERANCE);

    // Read manifest
    char manifest_path[512];
    snprintf(manifest_path, sizeof(manifest_path), "%s/manifest.txt", TEST_DIR);
    FILE *mf = fopen(manifest_path, "r");
    if (!mf) {
        fprintf(stderr, "ERROR: cannot open %s\n", manifest_path);
        fprintf(stderr, "Run 'python generate_test_vectors.py' first.\n");
        return 1;
    }

    int num_tests;
    if (fscanf(mf, "%d", &num_tests) != 1) {
        fprintf(stderr, "ERROR: cannot read test count from manifest\n");
        fclose(mf);
        return 1;
    }

    int failures = 0;
    for (int i = 0; i < num_tests; i++) {
        char name[256];
        if (fscanf(mf, "%s", name) != 1) {
            fprintf(stderr, "ERROR: cannot read test name %d from manifest\n", i);
            failures++;
            continue;
        }
        failures += run_test(name);
    }
    fclose(mf);

    printf("\n============================================================\n");
    if (failures == 0) {
        printf("ALL %d TESTS PASSED\n", num_tests);
    } else {
        printf("FAILED: %d / %d tests\n", failures, num_tests);
    }
    printf("============================================================\n");

    return (failures == 0) ? 0 : 1;
}
